import { Prose, H1, H2, H3, P, CodeBlock, InlineCode, List } from "@/components/prose"
import type { Metadata } from "next"

export const metadata: Metadata = {
  title: "Kotlin - Skir Documentation",
  description: "Learn how to use Skir-generated Kotlin code in your projects",
}

export default function KotlinPage() {
  return (
    <Prose>
      <H1>Kotlin</H1>
      <P>
        This guide explains how to use Skir-generated Kotlin code in your projects.
        The Kotlin plugin generates idiomatic data classes, sealed classes, and
        extension functions that integrate seamlessly with Kotlin applications.
      </P>

      <H2>Installation</H2>
      <P>
        First, add the Kotlin plugin to your <InlineCode>skir.yml</InlineCode> configuration:
      </P>
      <CodeBlock language="yaml">{`plugins:
  - name: kotlin
    out: src/main/kotlin/generated
    options:
      package: com.example.generated`}</CodeBlock>
      <P>
        Then add the runtime library to your <InlineCode>build.gradle.kts</InlineCode>:
      </P>
      <CodeBlock language="kotlin">{`dependencies {
    implementation("io.gepheum:skir-kotlin-runtime:1.0.0")
}`}</CodeBlock>

      <H2>Generated Code</H2>
      <P>
        For each Skir file, the Kotlin plugin generates a corresponding <InlineCode>.kt</InlineCode> file
        containing data classes and utility functions for working with your data types.
      </P>

      <H3>Structs</H3>
      <P>
        Each Skir struct becomes a Kotlin data class:
      </P>
      <CodeBlock language="skir">{`struct User {
  name: string @1
  age: int32 @2
  email?: string @3
}`}</CodeBlock>
      <P>becomes:</P>
      <CodeBlock language="kotlin">{`data class User(
    val name: String = "",
    val age: Int = 0,
    val email: String? = null
) {
    companion object {
        val DEFAULT = User()
    }
}`}</CodeBlock>

      <H3>Enums</H3>
      <P>
        Skir enums become Kotlin enum classes:
      </P>
      <CodeBlock language="skir">{`enum Status {
  pending @1
  approved @2
  rejected @3
}`}</CodeBlock>
      <P>becomes:</P>
      <CodeBlock language="kotlin">{`enum class Status(val value: Int) {
    PENDING(1),
    APPROVED(2),
    REJECTED(3);
    
    companion object {
        fun fromValue(value: Int): Status? =
            entries.find { it.value == value }
    }
}`}</CodeBlock>

      <H3>Oneofs (Union Types)</H3>
      <P>
        Skir oneofs become Kotlin sealed classes:
      </P>
      <CodeBlock language="skir">{`oneof Result {
  success: SuccessData @1
  error: ErrorData @2
}`}</CodeBlock>
      <P>becomes:</P>
      <CodeBlock language="kotlin">{`sealed class Result {
    data class Success(val value: SuccessData) : Result()
    data class Error(val value: ErrorData) : Result()
    
    companion object {
        fun success(value: SuccessData): Result = Success(value)
        fun error(value: ErrorData): Result = Error(value)
    }
}`}</CodeBlock>

      <H2>Serialization</H2>
      <P>
        The generated code includes serializers for converting between
        Kotlin objects and binary format:
      </P>
      <CodeBlock language="kotlin">{`import com.example.generated.User
import com.example.generated.UserSerializer

// Serialize to bytes
val bytes: ByteArray = UserSerializer.toBytes(user)

// Deserialize from bytes
val user: User = UserSerializer.fromBytes(bytes)

// Serialize to JSON string
val json: String = UserSerializer.toJson(user)

// Deserialize from JSON
val user2: User = UserSerializer.fromJson(json)`}</CodeBlock>

      <H2>Working with Generated Types</H2>

      <H3>Creating Instances</H3>
      <P>
        Use the data class constructor with named arguments:
      </P>
      <CodeBlock language="kotlin">{`val user = User(
    name = "Alice",
    age = 30,
    email = "alice@example.com"
)

// Using defaults
val user2 = User(name = "Bob", age = 25)`}</CodeBlock>

      <H3>Updating Instances</H3>
      <P>
        Use the <InlineCode>copy()</InlineCode> function provided by data classes:
      </P>
      <CodeBlock language="kotlin">{`val updated = user.copy(
    age = 31,
    email = "newemail@example.com"
)

// Original is unchanged
println(user.age)    // 30
println(updated.age) // 31`}</CodeBlock>

      <H3>Pattern Matching on Oneofs</H3>
      <P>
        Use Kotlin&apos;s <InlineCode>when</InlineCode> expression with sealed classes:
      </P>
      <CodeBlock language="kotlin">{`fun handleResult(result: Result): String = when (result) {
    is Result.Success -> "Success: \${result.value.message}"
    is Result.Error -> "Error: \${result.value.code}"
}

// With smart casting
fun handleResultVerbose(result: Result): String {
    return when (result) {
        is Result.Success -> {
            val data = result.value // Smart cast to SuccessData
            "Success: \${data.message}"
        }
        is Result.Error -> {
            val error = result.value // Smart cast to ErrorData
            "Error: \${error.code}"
        }
    }
}`}</CodeBlock>

      <H2>RPC Services</H2>
      <P>
        For Skir services, the Kotlin plugin generates interfaces for both
        client and server implementations:
      </P>
      <CodeBlock language="skir">{`service UserService {
  getUser(GetUserRequest): GetUserResponse
  createUser(CreateUserRequest): CreateUserResponse
}`}</CodeBlock>
      <P>generates:</P>
      <CodeBlock language="kotlin">{`interface UserServiceClient {
    suspend fun getUser(request: GetUserRequest): GetUserResponse
    suspend fun createUser(request: CreateUserRequest): CreateUserResponse
}

interface UserServiceHandler {
    suspend fun getUser(
        request: GetUserRequest,
        context: Context
    ): GetUserResponse
    
    suspend fun createUser(
        request: CreateUserRequest,
        context: Context
    ): CreateUserResponse
}`}</CodeBlock>

      <H2>Coroutines Support</H2>
      <P>
        The Kotlin plugin generates suspend functions for RPC methods,
        integrating seamlessly with Kotlin coroutines:
      </P>
      <CodeBlock language="kotlin">{`class MyUserService : UserServiceHandler {
    override suspend fun getUser(
        request: GetUserRequest,
        context: Context
    ): GetUserResponse {
        // Use coroutines for async operations
        val user = withContext(Dispatchers.IO) {
            database.findUser(request.userId)
        }
        return GetUserResponse(user = user)
    }
}`}</CodeBlock>

      <H2>Best Practices</H2>
      <List items={[
        "Use named arguments for clarity when creating data classes",
        "Leverage copy() for immutable updates",
        "Use sealed class exhaustive when expressions for type safety",
        "Take advantage of Kotlin's null safety with nullable fields",
        "Use coroutines for async RPC operations",
        "Keep generated code in a separate package and don't modify it manually",
      ]} />
    </Prose>
  )
}
